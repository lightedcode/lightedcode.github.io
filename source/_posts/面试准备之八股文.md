---
title: 面试准备之八股文
date: 2024-08-06 10:07:42
cover_image:
cover_image_alt:
tags:
    - Interview
    - 八股文
categories:
    - Code
---

# 1. 数据结构和算法

## 1.1 在微服务架构中遇到过哪些挑战？

1. 服务间通信的问题：
在微服务架构中，各个服务之间要进行相互的通信，服务间通信的可靠性，延迟和错误处理都需要考虑
- 解决方案：
  - 通过API网关来进行路由请求的管理
  - 消息队列：通过消息队列进行异步通信
  - 通信失败后的重试机制

2. 数据一致性：
在分布式的系统中保证数据一致性比较复杂
- 解决方案：
  - 最终一致性：而不是强一致性，通过异步处理和补偿机制来达到数据一致性
  - 幂等操作：每个请求携带唯一的ID，保障相同请求只处理一次
  - 分布式锁
  - 分布式事务（2PC两阶段提交，3PC三阶段提交）
3. 监控和调试
4. 运维和部署

## 1.2 布隆过滤器的使用场景
- 如果面试的问题是黑名单，并且允许出错。可以使用布隆过滤器解决
- 使用位图作为存储的数据结构，可以节省空间
- 先初始化一个m长度的位图
- 对数据进行k次哈希函数，然后对m取模，得到一个index
- 将这个index设置为1
- 

# 2. 数据库相关

## 2.1. 什么场景下索引会失效

 - 使用 % like查询时
 - 使用不等于(!= <>)操作符
 - 类型隐转
   - 比如没有按照索引字段的类型传入，比如索引类型是字符串，传入的是数字
 - 未满足最左匹配要求
   - 比如一个复合索引(a,b,c)，如果直接搜索where b = xx的时候就会失效
   - 是因为b+树存储复合索引的时候是按照索引的顺序保存的，如果没有前置条件无法快速查询到索引

## 2.2. 基于Redis的分布式锁会有什么问题？

1. 在高并发环境下，可能会出现性能问题：尽量减少锁的获取和释放次数
2. 如果客户端失去连接等情况下可能出现锁锁失效的问题：锁续期

## 2.3. 如何基于Redis锁进行续期？

1. **获取锁**：使用`SET`命令获取锁，并设置锁的过期时间。

2. **启动续期线程**：在获取锁之后，启动一个专门的线程或任务来定期续期锁。

3. **定期续期**：在续期线程中，定期检查锁的状态，并在锁即将过期时，延长锁的过期时间。

4. **释放锁**：在任务完成后，释放锁，并停止续期线程。

## 2.4. Redis集群模式和哨兵模式的区别

## 2.5. Redis持久化的方案是什么

### 1. RDB (Redis Database File)
RDB 是 Redis 的快照持久化方式，它会在指定的时间间隔内生成数据的快照并保存到磁盘上。

#### 特点
- **性能高**：RDB 文件是在后台生成的，不会影响 Redis 的性能。
- **恢复速度快**：RDB 文件是二进制格式，加载速度快。
- **数据丢失风险**：由于是定时快照，可能会丢失最后一次快照之后的数据。

#### 配置
可以通过配置文件中的 `save` 选项设置 RDB 的保存策略，例如：
```
save 900 1  # 900秒内至少有1次写操作
save 300 10 # 300秒内至少有10次写操作
save 60 10000 # 60秒内至少有10000次写操作
```

#### 适用场景
- **数据丢失容忍度高**：适用于对数据丢失容忍度较高的场景。
- **快速恢复需求**：需要快速恢复数据的场景。

### 2. AOF (Append Only File)
AOF 是 Redis 的日志持久化方式，它会将每个写操作记录到日志文件中。

#### 特点
- **数据安全性高**：AOF 可以配置为每个写操作都同步到磁盘，确保数据不丢失。
- **文件大小可控**：通过日志重写机制，可以控制 AOF 文件的大小。
- **恢复速度相对较慢**：由于需要重放所有的写操作，恢复速度比 RDB 慢。

#### 配置
可以通过配置文件中的 `appendonly` 选项启用 AOF：
```
appendonly yes
appendfsync always  # 每个写操作都同步到磁盘
# appendfsync everysec  # 每秒同步一次
# appendfsync no  # 不主动同步，由操作系统决定
```

#### 适用场景
- **数据丢失容忍度低**：适用于对数据丢失容忍度低的场景。
- **高数据安全性需求**：需要高数据安全性的场景。

### 3. 混合持久化 (RDB + AOF)
Redis 4.0 引入了混合持久化模式，结合了 RDB 和 AOF 的优点。在这种模式下，Redis 会在生成 RDB 快照的同时，记录 AOF 日志。

#### 特点
- **数据安全性和恢复速度兼顾**：既有 RDB 的快速恢复速度，又有 AOF 的高数据安全性。
- **文件大小适中**：通过混合持久化，可以控制持久化文件的大小。

#### 配置
可以通过配置文件中的 `aof-use-rdb-preamble` 选项启用混合持久化：
```
aof-use-rdb-preamble yes
```

#### 适用场景
- **数据安全性和恢复速度并重**：适用于需要兼顾数据安全性和恢复速度的场景。

### 4. 无持久化
在某些场景下，可能不需要持久化数据，例如缓存场景。

#### 特点
- **性能最优**：无需持久化操作，性能最高。
- **数据丢失风险高**：服务器重启或故障时，数据会丢失。

#### 适用场景
- **缓存应用**：适用于缓存场景，对数据丢失不敏感。

## 2.6 InnoDB的结构是什么？一页的大小是多少？为什么这么设计？

- InnoDB采用了B+树作为数据存储的结构，搜索性能良好，支持事务和外键。支持行锁和表锁
- 一页设置为16KB

1. **平衡I/O性能与存储效率**：
   - 16KB的页大小在大多数情况下能够提供较好的I/O性能和存储效率之间的平衡。较小的页大小可能会导致更多的I/O操作，而较大的页大小可能会浪费存储空间。

2. **适应大多数工作负载**：
   - 16KB的页大小适用于各种类型的工作负载，包括读密集型和写密集型应用。它能够有效地缓存和管理数据页，从而提高数据库的整体性能。

3. **减少碎片**：
   - 较大的页大小有助于减少存储碎片，因为更多的数据可以被紧凑地存储在单个页中，从而减少了磁盘上的不连续存储。

## 2.7 事务的隔离级别有哪些？

1. **读未提交（Read Uncommitted）**：
   - **特性**：允许事务读取其他事务尚未提交的更改。
   - **问题**：可能会发生脏读（Dirty Read）。
   - **应用场景**：很少使用，适用于对一致性要求极低的场景。

2. **读已提交（Read Committed）**：
   - **特性**：只允许事务读取其他事务已提交的更改。
   - **问题**：可能会发生不可重复读（Non-repeatable Read）。
   - **应用场景**：大多数数据库系统的默认隔离级别，适用于大部分应用场景。

3. **可重复读（Repeatable Read）**：
   - **特性**：确保在同一事务中多次读取同一数据时，数据值保持一致。
   - **问题**：可能会发生幻读（Phantom Read）。
   - **应用场景**：适用于需要确保读取数据一致性的场景。

4. **可串行化（Serializable）**：
   - **特性**：最高的隔离级别，完全锁定读取的行，防止其他事务进行插入、更新或删除操作。
   - **问题**：避免了脏读、不可重复读和幻读。
   - **应用场景**：适用于需要严格数据一致性且并发量较低的场景。

# 3. 设计模式

## 3.1. 单例模式

1. **控制资源的使用**：例如，数据库连接池、日志系统等，这些资源通常是重量级的，创建多个实例会导致资源浪费。
2. **全局状态管理**：在某些情况下，需要在整个应用程序中共享状态或配置，单例模式可以确保所有模块访问同一个实例。
3. **跨模块通信**：单例模式可以在不同模块之间传递信息，而不需要显式地传递对象。

```python
class Singleton:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(Singleton, cls).__new__(cls, *args, **kwargs)
        return cls._instance
```

# 4. 系统设计

# 5. 计算机网络相关

## 5.1 HTTPS和HTTP的区别

- 安全性：HTTPS比HTTP更安全，因为数据都经过了TLS/SSL加密传输，HTTP是明文传输
- 速度；HTTP速度比较快，HTTPS还需要加解密过程
- 端口：HTTP是80端口，HTTPS是443端口
- 证书：HTTPS需要CA证书

## 5.2 HTTPS连接建立的过程

- 客户端发起连接请求
- 服务端发送证书给客户端，客户端验证证书的有效性（域名，过期时间等）
- 客户端将一个对称加密的密钥通过服务端的公钥加密，发送给服务端
- 服务端用自己的私钥解密出密钥
- 客户端和服务端用对称加密后的数据进行传输数据

## 5.3 DNS是什么？用了什么协议？

- DNS（Domain Name System），使用**UDP**协议，但是当**传输的数据很大**的时候，会使用**TCP**协议

## 5.4 DNS解析过程

- 用户访问url后开始DNS解析
- 查询本地缓存，包括HOST
- 查询本地DNS服务器
- 本地DNS服务器先查询缓存
- 查询根DNS服务器，返回顶级域名的DNS服务器
- 顶级域名DNS服务器查询到权威DNS服务器
- 权威DNS服务器返回IP地址


## 5.4 TCP和UDP的区别

- TCP协议是可靠的，因为连接的建立和断开都是双方确认过的。
- UDP协议是不可靠的，传输数据快


## 5.5 TCP和UDP在应用层有什么协议

- TCP: HTTP，HTTPS；FTP（文件传输）；IMAP/POP3（邮件）；SMTP（发送邮件）；SSH等
- UDP：DNS；RTP（实时传输协议）；DHCP（动态主机配置）

